{"language":"Solidity","sources":{"src/YieldVault.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.23;\n\nimport {IERC20} from \"lib/forge-std/src/interfaces/IERC20.sol\";\n\n/**\n * @title YieldVault\n * @notice Core vault contract for the YieldEdge zero-loss prediction market.\n * @dev Manages user deposits of yield-bearing assets and tracks principal vs. accrued yield.\n * \n * Key Concepts:\n * - Principal: The original amount deposited by the user (always protected).\n * - Yield: The interest earned on the principal (used as prediction stakes).\n * - When a user deposits, we record their \"principal\" and the current exchange rate.\n * - The difference between current value and principal = claimable yield.\n */\ncontract YieldVault {\n    // ============ Structs ============\n    \n    struct UserDeposit {\n        uint256 shares;              // Shares in the underlying yield asset\n        uint256 principalValue;      // Original value at deposit time (in asset units)\n        uint256 depositTime;         // Timestamp of deposit\n        uint256 lockedYield;         // Yield locked for active predictions\n    }\n\n    // ============ State Variables ============\n    \n    /// @notice The yield-bearing asset (e.g., MockUSDY, real USDY, or mETH)\n    IERC20 public immutable asset;\n    \n    /// @notice Interface for getting the exchange rate from the yield asset\n    IYieldAsset public immutable yieldAsset;\n    \n    /// @notice User deposits\n    mapping(address => UserDeposit) public deposits;\n    \n    /// @notice Total shares in the vault\n    uint256 public totalShares;\n    \n    /// @notice Authorized market contracts that can lock/unlock yield\n    mapping(address => bool) public authorizedMarkets;\n    \n    /// @notice Authorized factory contract that can authorize markets\n    address public authorizedFactory;\n    \n    /// @notice Owner of the vault\n    address public owner;\n\n    // ============ Events ============\n    \n    event Deposited(address indexed user, uint256 amount, uint256 shares);\n    event Withdrawn(address indexed user, uint256 principal, uint256 yield);\n    event YieldLocked(address indexed user, uint256 amount, address indexed market);\n    event YieldUnlocked(address indexed user, uint256 amount, address indexed market);\n    event MarketAuthorized(address indexed market, bool authorized);\n    event FactoryAuthorized(address indexed factory);\n\n    // ============ Modifiers ============\n    \n    modifier onlyOwner() {\n        require(msg.sender == owner, \"YieldVault: not owner\");\n        _;\n    }\n    \n    modifier onlyOwnerOrFactory() {\n        require(msg.sender == owner || msg.sender == authorizedFactory, \"YieldVault: not authorized\");\n        _;\n    }\n    \n    modifier onlyAuthorizedMarket() {\n        require(authorizedMarkets[msg.sender], \"YieldVault: not authorized market\");\n        _;\n    }\n\n    // ============ Constructor ============\n    \n    constructor(address _asset) {\n        asset = IERC20(_asset);\n        yieldAsset = IYieldAsset(_asset);\n        owner = msg.sender;\n    }\n\n    // ============ User Functions ============\n    \n    /**\n     * @notice Deposit yield-bearing assets into the vault.\n     * @param amount The amount of assets to deposit.\n     */\n    function deposit(uint256 amount) external {\n        require(amount > 0, \"YieldVault: zero amount\");\n        \n        // Transfer assets from user\n        require(asset.transferFrom(msg.sender, address(this), amount), \"YieldVault: transfer failed\");\n        \n        // Calculate shares based on current exchange rate\n        uint256 rate = yieldAsset.exchangeRate();\n        uint256 shares = (amount * 1e18) / rate;\n        \n        // Update user deposit\n        UserDeposit storage userDeposit = deposits[msg.sender];\n        userDeposit.shares += shares;\n        userDeposit.principalValue += amount;\n        if (userDeposit.depositTime == 0) {\n            userDeposit.depositTime = block.timestamp;\n        }\n        \n        totalShares += shares;\n        \n        emit Deposited(msg.sender, amount, shares);\n    }\n\n    /**\n     * @notice Withdraw all assets (principal + unlocked yield) from the vault.\n     * @dev User cannot withdraw if they have yield locked in active predictions.\n     */\n    function withdraw() external {\n        UserDeposit storage userDeposit = deposits[msg.sender];\n        require(userDeposit.shares > 0, \"YieldVault: no deposit\");\n        require(userDeposit.lockedYield == 0, \"YieldVault: yield locked in prediction\");\n        \n        uint256 shares = userDeposit.shares;\n        uint256 principal = userDeposit.principalValue;\n        \n        // Calculate current value\n        uint256 rate = yieldAsset.exchangeRate();\n        uint256 currentValue = (shares * rate) / 1e18;\n        uint256 yieldEarned = currentValue > principal ? currentValue - principal : 0;\n        \n        // Reset user deposit\n        delete deposits[msg.sender];\n        totalShares -= shares;\n        \n        // Transfer assets back to user\n        require(asset.transfer(msg.sender, currentValue), \"YieldVault: transfer failed\");\n        \n        emit Withdrawn(msg.sender, principal, yieldEarned);\n    }\n\n    // ============ View Functions ============\n    \n    /**\n     * @notice Get the current value of a user's deposit.\n     * @param user The user address.\n     * @return currentValue The total current value (principal + yield).\n     * @return principal The original principal amount.\n     * @return unlockedYield The yield available for predictions.\n     * @return lockedYield The yield already locked in predictions.\n     */\n    function getDepositInfo(address user) external view returns (\n        uint256 currentValue,\n        uint256 principal,\n        uint256 unlockedYield,\n        uint256 lockedYield\n    ) {\n        UserDeposit storage userDeposit = deposits[user];\n        if (userDeposit.shares == 0) {\n            return (0, 0, 0, 0);\n        }\n        \n        uint256 rate = yieldAsset.exchangeRate();\n        currentValue = (userDeposit.shares * rate) / 1e18;\n        principal = userDeposit.principalValue;\n        lockedYield = userDeposit.lockedYield;\n        \n        uint256 totalYield = currentValue > principal ? currentValue - principal : 0;\n        unlockedYield = totalYield > lockedYield ? totalYield - lockedYield : 0;\n    }\n\n    /**\n     * @notice Get the available yield for a user to use in predictions.\n     * @param user The user address.\n     * @return The available yield amount.\n     */\n    function getAvailableYield(address user) external view returns (uint256) {\n        UserDeposit storage userDeposit = deposits[user];\n        if (userDeposit.shares == 0) {\n            return 0;\n        }\n        \n        uint256 rate = yieldAsset.exchangeRate();\n        uint256 currentValue = (userDeposit.shares * rate) / 1e18;\n        uint256 totalYield = currentValue > userDeposit.principalValue \n            ? currentValue - userDeposit.principalValue \n            : 0;\n        \n        return totalYield > userDeposit.lockedYield \n            ? totalYield - userDeposit.lockedYield \n            : 0;\n    }\n\n    // ============ Market Functions ============\n    \n    /**\n     * @notice Lock a portion of a user's yield for a prediction.\n     * @dev Only callable by authorized market contracts.\n     * @param user The user whose yield to lock.\n     * @param amount The amount of yield to lock.\n     */\n    function lockYield(address user, uint256 amount) external onlyAuthorizedMarket {\n        UserDeposit storage userDeposit = deposits[user];\n        \n        uint256 rate = yieldAsset.exchangeRate();\n        uint256 currentValue = (userDeposit.shares * rate) / 1e18;\n        uint256 totalYield = currentValue > userDeposit.principalValue \n            ? currentValue - userDeposit.principalValue \n            : 0;\n        uint256 availableYield = totalYield > userDeposit.lockedYield \n            ? totalYield - userDeposit.lockedYield \n            : 0;\n        \n        require(amount <= availableYield, \"YieldVault: insufficient yield\");\n        \n        userDeposit.lockedYield += amount;\n        \n        emit YieldLocked(user, amount, msg.sender);\n    }\n\n    /**\n     * @notice Unlock a portion of a user's yield after a prediction resolves.\n     * @dev Only callable by authorized market contracts.\n     * @param user The user whose yield to unlock.\n     * @param amount The amount of yield to unlock.\n     */\n    function unlockYield(address user, uint256 amount) external onlyAuthorizedMarket {\n        UserDeposit storage userDeposit = deposits[user];\n        require(userDeposit.lockedYield >= amount, \"YieldVault: insufficient locked yield\");\n        \n        userDeposit.lockedYield -= amount;\n        \n        emit YieldUnlocked(user, amount, msg.sender);\n    }\n\n    /**\n     * @notice Transfer locked yield from loser to winner after prediction resolves.\n     * @dev Only callable by authorized market contracts.\n     * @param from The loser's address.\n     * @param to The winner's address.\n     * @param amount The amount of yield to transfer.\n     */\n    function transferYield(address from, address to, uint256 amount) external onlyAuthorizedMarket {\n        UserDeposit storage fromDeposit = deposits[from];\n        UserDeposit storage toDeposit = deposits[to];\n        \n        require(fromDeposit.lockedYield >= amount, \"YieldVault: insufficient locked yield\");\n        \n        // Calculate shares to transfer based on current rate\n        uint256 rate = yieldAsset.exchangeRate();\n        uint256 sharesToTransfer = (amount * 1e18) / rate;\n        \n        require(fromDeposit.shares >= sharesToTransfer, \"YieldVault: insufficient shares\");\n        \n        // Transfer shares (the yield portion)\n        fromDeposit.shares -= sharesToTransfer;\n        fromDeposit.lockedYield -= amount;\n        \n        toDeposit.shares += sharesToTransfer;\n        \n        // Note: Winner's principal doesn't change, only their shares increase\n        // This means their \"yield\" calculation will show the transferred amount\n    }\n\n    // ============ Admin Functions ============\n    \n    /**\n     * @notice Authorize or deauthorize a market contract.\n     * @dev Can be called by owner or authorized factory.\n     * @param market The market contract address.\n     * @param authorized Whether to authorize or deauthorize.\n     */\n    function setMarketAuthorization(address market, bool authorized) external onlyOwnerOrFactory {\n        authorizedMarkets[market] = authorized;\n        emit MarketAuthorized(market, authorized);\n    }\n    \n    /**\n     * @notice Set the authorized factory contract.\n     * @param factory The factory contract address.\n     */\n    function setAuthorizedFactory(address factory) external onlyOwner {\n        authorizedFactory = factory;\n        emit FactoryAuthorized(factory);\n    }\n}\n\n// ============ Interface ============\n\ninterface IYieldAsset {\n    function exchangeRate() external view returns (uint256);\n}\n"},"lib/forge-std/src/interfaces/IERC20.sol":{"content":"// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity >=0.6.2;\n\n/// @dev Interface of the ERC20 standard as defined in the EIP.\n/// @dev This includes the optional name, symbol, and decimals metadata.\ninterface IERC20 {\n    /// @dev Emitted when `value` tokens are moved from one account (`from`) to another (`to`).\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /// @dev Emitted when the allowance of a `spender` for an `owner` is set, where `value`\n    /// is the new allowance.\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /// @notice Returns the amount of tokens in existence.\n    function totalSupply() external view returns (uint256);\n\n    /// @notice Returns the amount of tokens owned by `account`.\n    function balanceOf(address account) external view returns (uint256);\n\n    /// @notice Moves `amount` tokens from the caller's account to `to`.\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /// @notice Returns the remaining number of tokens that `spender` is allowed\n    /// to spend on behalf of `owner`\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /// @notice Sets `amount` as the allowance of `spender` over the caller's tokens.\n    /// @dev Be aware of front-running risks: https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /// @notice Moves `amount` tokens from `from` to `to` using the allowance mechanism.\n    /// `amount` is then deducted from the caller's allowance.\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n\n    /// @notice Returns the name of the token.\n    function name() external view returns (string memory);\n\n    /// @notice Returns the symbol of the token.\n    function symbol() external view returns (string memory);\n\n    /// @notice Returns the decimals places of the token.\n    function decimals() external view returns (uint8);\n}\n"}},"settings":{"remappings":["forge-std/=lib/forge-std/src/"],"optimizer":{"enabled":true,"runs":200},"metadata":{"useLiteralContent":false,"bytecodeHash":"ipfs","appendCBOR":true},"outputSelection":{"*":{"":["ast"],"*":["abi","evm.bytecode.object","evm.bytecode.sourceMap","evm.bytecode.linkReferences","evm.deployedBytecode.object","evm.deployedBytecode.sourceMap","evm.deployedBytecode.linkReferences","evm.deployedBytecode.immutableReferences","evm.methodIdentifiers","metadata"]}},"evmVersion":"shanghai","viaIR":false,"libraries":{}}}
