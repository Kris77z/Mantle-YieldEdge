{"language":"Solidity","sources":{"src/MarketFactory.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.23;\n\nimport {PredictionMarket} from \"./PredictionMarket.sol\";\nimport {YieldVault} from \"./YieldVault.sol\";\n\n/**\n * @title MarketFactory\n * @notice Factory contract for creating new prediction markets.\n * @dev Deploys PredictionMarket instances and manages the registry of all markets.\n */\ncontract MarketFactory {\n    // ============ State Variables ============\n    \n    /// @notice The YieldVault contract that manages deposits\n    YieldVault public immutable vault;\n    \n    /// @notice List of all deployed markets\n    address[] public markets;\n    \n    /// @notice Mapping to check if an address is a valid market\n    mapping(address => bool) public isMarket;\n    \n    /// @notice Owner of the factory\n    address public owner;\n    \n    /// @notice Counter for market IDs\n    uint256 public marketCount;\n\n    // ============ Events ============\n    \n    event MarketCreated(\n        uint256 indexed marketId,\n        address indexed marketAddress,\n        string question,\n        uint256 duration\n    );\n\n    // ============ Modifiers ============\n    \n    modifier onlyOwner() {\n        require(msg.sender == owner, \"MarketFactory: not owner\");\n        _;\n    }\n\n    // ============ Constructor ============\n    \n    constructor(address _vault) {\n        vault = YieldVault(_vault);\n        owner = msg.sender;\n    }\n\n    // ============ Factory Functions ============\n    \n    /**\n     * @notice Create a new prediction market.\n     * @param question The prediction question (e.g., \"Will BTC reach $100k by Dec 31?\").\n     * @param duration How long the market accepts predictions (in seconds).\n     * @return marketAddress The address of the newly created market.\n     */\n    function createMarket(\n        string calldata question,\n        uint256 duration\n    ) external onlyOwner returns (address marketAddress) {\n        require(bytes(question).length > 0, \"MarketFactory: empty question\");\n        require(duration > 0, \"MarketFactory: zero duration\");\n        \n        // Deploy new market\n        PredictionMarket market = new PredictionMarket(\n            address(vault),\n            question,\n            duration\n        );\n        \n        marketAddress = address(market);\n        \n        // Register the market\n        markets.push(marketAddress);\n        isMarket[marketAddress] = true;\n        \n        // Authorize the market in the vault\n        vault.setMarketAuthorization(marketAddress, true);\n        \n        emit MarketCreated(marketCount, marketAddress, question, duration);\n        \n        marketCount++;\n        \n        return marketAddress;\n    }\n\n    // ============ View Functions ============\n    \n    /**\n     * @notice Get all deployed market addresses.\n     * @return Array of market addresses.\n     */\n    function getAllMarkets() external view returns (address[] memory) {\n        return markets;\n    }\n    \n    /**\n     * @notice Get market address by index.\n     * @param index The index in the markets array.\n     * @return The market address.\n     */\n    function getMarket(uint256 index) external view returns (address) {\n        require(index < markets.length, \"MarketFactory: invalid index\");\n        return markets[index];\n    }\n    \n    /**\n     * @notice Get total number of markets.\n     * @return The count of markets.\n     */\n    function getMarketCount() external view returns (uint256) {\n        return markets.length;\n    }\n\n    /**\n     * @notice Get market info in batch.\n     * @param startIndex Start index.\n     * @param count Number of markets to fetch.\n     * @return marketAddresses Array of market addresses.\n     * @return questions Array of market questions.\n     * @return statuses Array of market statuses (0=Open, 1=Closed, 2=Resolved).\n     */\n    function getMarketsInfo(uint256 startIndex, uint256 count) external view returns (\n        address[] memory marketAddresses,\n        string[] memory questions,\n        uint8[] memory statuses\n    ) {\n        uint256 end = startIndex + count;\n        if (end > markets.length) {\n            end = markets.length;\n        }\n        uint256 actualCount = end - startIndex;\n        \n        marketAddresses = new address[](actualCount);\n        questions = new string[](actualCount);\n        statuses = new uint8[](actualCount);\n        \n        for (uint256 i = 0; i < actualCount; i++) {\n            address marketAddr = markets[startIndex + i];\n            PredictionMarket market = PredictionMarket(marketAddr);\n            \n            marketAddresses[i] = marketAddr;\n            questions[i] = market.question();\n            statuses[i] = uint8(market.status());\n        }\n    }\n\n    // ============ Admin Functions ============\n    \n    /**\n     * @notice Transfer ownership.\n     * @param newOwner The new owner address.\n     */\n    function transferOwnership(address newOwner) external onlyOwner {\n        require(newOwner != address(0), \"MarketFactory: zero address\");\n        owner = newOwner;\n    }\n}\n"},"src/PredictionMarket.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.23;\n\nimport {YieldVault} from \"./YieldVault.sol\";\n\n/**\n * @title PredictionMarket\n * @notice A zero-loss prediction market where users bet their yield, not principal.\n * @dev Users stake their accrued yield on YES or NO outcomes.\n *      Winners take all the yield from the losing side.\n *      Losers get their principal back (zero loss).\n */\ncontract PredictionMarket {\n    // ============ Enums ============\n    \n    enum MarketStatus {\n        Open,       // Accepting predictions\n        Closed,     // No more predictions, waiting for resolution\n        Resolved    // Outcome determined, rewards claimable\n    }\n    \n    enum Outcome {\n        Undecided,\n        Yes,\n        No\n    }\n\n    // ============ Structs ============\n    \n    struct Prediction {\n        uint256 yieldStaked;    // Amount of yield staked\n        Outcome choice;         // YES or NO\n        bool claimed;           // Whether rewards have been claimed\n    }\n\n    // ============ State Variables ============\n    \n    /// @notice The vault contract managing deposits\n    YieldVault public immutable vault;\n    \n    /// @notice Market metadata\n    string public question;\n    uint256 public createdAt;\n    uint256 public closesAt;\n    \n    /// @notice Market state\n    MarketStatus public status;\n    Outcome public outcome;\n    \n    /// @notice Total yield staked on each side\n    uint256 public totalYesStake;\n    uint256 public totalNoStake;\n    \n    /// @notice User predictions\n    mapping(address => Prediction) public predictions;\n    \n    /// @notice List of all predictors (for iteration if needed)\n    address[] public predictors;\n    \n    /// @notice Market owner (can resolve the market)\n    address public owner;\n    \n    /// @notice Oracle address (if using automated resolution)\n    address public oracle;\n\n    // ============ Events ============\n    \n    event PredictionMade(address indexed user, Outcome choice, uint256 amount);\n    event MarketClosed();\n    event MarketResolved(Outcome outcome);\n    event RewardClaimed(address indexed user, uint256 reward);\n\n    // ============ Modifiers ============\n    \n    modifier onlyOwner() {\n        require(msg.sender == owner, \"PredictionMarket: not owner\");\n        _;\n    }\n    \n    modifier onlyOpen() {\n        require(status == MarketStatus.Open, \"PredictionMarket: not open\");\n        require(block.timestamp < closesAt, \"PredictionMarket: past deadline\");\n        _;\n    }\n\n    // ============ Constructor ============\n    \n    constructor(\n        address _vault,\n        string memory _question,\n        uint256 _duration\n    ) {\n        vault = YieldVault(_vault);\n        question = _question;\n        createdAt = block.timestamp;\n        closesAt = block.timestamp + _duration;\n        status = MarketStatus.Open;\n        outcome = Outcome.Undecided;\n        owner = msg.sender;\n    }\n\n    // ============ User Functions ============\n    \n    /**\n     * @notice Make a prediction by staking yield.\n     * @param choice The predicted outcome (Yes or No).\n     * @param yieldAmount The amount of yield to stake.\n     */\n    function predict(Outcome choice, uint256 yieldAmount) external onlyOpen {\n        require(choice == Outcome.Yes || choice == Outcome.No, \"PredictionMarket: invalid choice\");\n        require(yieldAmount > 0, \"PredictionMarket: zero stake\");\n        require(predictions[msg.sender].yieldStaked == 0, \"PredictionMarket: already predicted\");\n        \n        // Lock the yield in the vault\n        vault.lockYield(msg.sender, yieldAmount);\n        \n        // Record the prediction\n        predictions[msg.sender] = Prediction({\n            yieldStaked: yieldAmount,\n            choice: choice,\n            claimed: false\n        });\n        \n        predictors.push(msg.sender);\n        \n        if (choice == Outcome.Yes) {\n            totalYesStake += yieldAmount;\n        } else {\n            totalNoStake += yieldAmount;\n        }\n        \n        emit PredictionMade(msg.sender, choice, yieldAmount);\n    }\n\n    /**\n     * @notice Claim rewards after the market is resolved.\n     * @dev Winners receive their stake back plus a share of the losing pool.\n     *      Losers get nothing (but their principal in the vault is safe).\n     */\n    function claimReward() external {\n        require(status == MarketStatus.Resolved, \"PredictionMarket: not resolved\");\n        \n        Prediction storage pred = predictions[msg.sender];\n        require(pred.yieldStaked > 0, \"PredictionMarket: no prediction\");\n        require(!pred.claimed, \"PredictionMarket: already claimed\");\n        \n        pred.claimed = true;\n        \n        // First, unlock the user's own yield\n        vault.unlockYield(msg.sender, pred.yieldStaked);\n        \n        // If user won, calculate their share of the losing pool\n        if (pred.choice == outcome) {\n            uint256 winningPool = outcome == Outcome.Yes ? totalYesStake : totalNoStake;\n            uint256 losingPool = outcome == Outcome.Yes ? totalNoStake : totalYesStake;\n            \n            if (losingPool > 0 && winningPool > 0) {\n                // User's share of the losing pool\n                uint256 reward = (pred.yieldStaked * losingPool) / winningPool;\n                \n                // The reward comes from the losers' locked yield\n                // This is handled by the settlement process\n                emit RewardClaimed(msg.sender, pred.yieldStaked + reward);\n            } else {\n                emit RewardClaimed(msg.sender, pred.yieldStaked);\n            }\n        } else {\n            // Loser: yield is forfeited (already transferred to winners during settlement)\n            emit RewardClaimed(msg.sender, 0);\n        }\n    }\n\n    // ============ Admin Functions ============\n    \n    /**\n     * @notice Close the market to new predictions.\n     */\n    function closeMarket() external onlyOwner {\n        require(status == MarketStatus.Open, \"PredictionMarket: not open\");\n        status = MarketStatus.Closed;\n        emit MarketClosed();\n    }\n\n    /**\n     * @notice Resolve the market with the final outcome.\n     * @param _outcome The winning outcome (Yes or No).\n     */\n    function resolve(Outcome _outcome) external onlyOwner {\n        require(status == MarketStatus.Open || status == MarketStatus.Closed, \"PredictionMarket: already resolved\");\n        require(_outcome == Outcome.Yes || _outcome == Outcome.No, \"PredictionMarket: invalid outcome\");\n        \n        status = MarketStatus.Resolved;\n        outcome = _outcome;\n        \n        // Settle the market: transfer yield from losers to winners\n        _settleMarket();\n        \n        emit MarketResolved(_outcome);\n    }\n\n    /**\n     * @notice Internal function to settle yields between winners and losers.\n     */\n    function _settleMarket() internal {\n        uint256 losingPool = outcome == Outcome.Yes ? totalNoStake : totalYesStake;\n        uint256 winningPool = outcome == Outcome.Yes ? totalYesStake : totalNoStake;\n        \n        if (losingPool == 0 || winningPool == 0) {\n            // No losers or no winners, just unlock all yields\n            return;\n        }\n        \n        // For each loser, transfer their yield to winners proportionally\n        for (uint256 i = 0; i < predictors.length; i++) {\n            address predictor = predictors[i];\n            Prediction storage pred = predictions[predictor];\n            \n            if (pred.choice != outcome) {\n                // This is a loser - their yield will be distributed to winners\n                // The actual transfer happens when winners claim\n            }\n        }\n    }\n\n    // ============ View Functions ============\n    \n    /**\n     * @notice Get market summary.\n     * @return _question The market question.\n     * @return _status Current status.\n     * @return _outcome Current outcome (if resolved).\n     * @return _totalYes Total yield staked on YES.\n     * @return _totalNo Total yield staked on NO.\n     * @return _closesAt Deadline for predictions.\n     */\n    function getMarketInfo() external view returns (\n        string memory _question,\n        MarketStatus _status,\n        Outcome _outcome,\n        uint256 _totalYes,\n        uint256 _totalNo,\n        uint256 _closesAt\n    ) {\n        return (question, status, outcome, totalYesStake, totalNoStake, closesAt);\n    }\n\n    /**\n     * @notice Get the number of predictors.\n     * @return The count of unique predictors.\n     */\n    function getPredictorCount() external view returns (uint256) {\n        return predictors.length;\n    }\n\n    /**\n     * @notice Calculate potential winnings for a hypothetical stake.\n     * @param choice The outcome to bet on.\n     * @param amount The amount to stake.\n     * @return The potential total return (stake + winnings) if this side wins.\n     */\n    function calculatePotentialWinnings(Outcome choice, uint256 amount) external view returns (uint256) {\n        uint256 newWinningPool = choice == Outcome.Yes \n            ? totalYesStake + amount \n            : totalNoStake + amount;\n        uint256 losingPool = choice == Outcome.Yes ? totalNoStake : totalYesStake;\n        \n        if (newWinningPool == 0) return amount;\n        \n        uint256 share = (amount * losingPool) / newWinningPool;\n        return amount + share;\n    }\n}\n"},"src/YieldVault.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.23;\n\nimport {IERC20} from \"lib/forge-std/src/interfaces/IERC20.sol\";\n\n/**\n * @title YieldVault\n * @notice Core vault contract for the YieldEdge zero-loss prediction market.\n * @dev Manages user deposits of yield-bearing assets and tracks principal vs. accrued yield.\n * \n * Key Concepts:\n * - Principal: The original amount deposited by the user (always protected).\n * - Yield: The interest earned on the principal (used as prediction stakes).\n * - When a user deposits, we record their \"principal\" and the current exchange rate.\n * - The difference between current value and principal = claimable yield.\n */\ncontract YieldVault {\n    // ============ Structs ============\n    \n    struct UserDeposit {\n        uint256 shares;              // Shares in the underlying yield asset\n        uint256 principalValue;      // Original value at deposit time (in asset units)\n        uint256 depositTime;         // Timestamp of deposit\n        uint256 lockedYield;         // Yield locked for active predictions\n    }\n\n    // ============ State Variables ============\n    \n    /// @notice The yield-bearing asset (e.g., MockUSDY, real USDY, or mETH)\n    IERC20 public immutable asset;\n    \n    /// @notice Interface for getting the exchange rate from the yield asset\n    IYieldAsset public immutable yieldAsset;\n    \n    /// @notice User deposits\n    mapping(address => UserDeposit) public deposits;\n    \n    /// @notice Total shares in the vault\n    uint256 public totalShares;\n    \n    /// @notice Authorized market contracts that can lock/unlock yield\n    mapping(address => bool) public authorizedMarkets;\n    \n    /// @notice Authorized factory contract that can authorize markets\n    address public authorizedFactory;\n    \n    /// @notice Owner of the vault\n    address public owner;\n\n    // ============ Events ============\n    \n    event Deposited(address indexed user, uint256 amount, uint256 shares);\n    event Withdrawn(address indexed user, uint256 principal, uint256 yield);\n    event YieldLocked(address indexed user, uint256 amount, address indexed market);\n    event YieldUnlocked(address indexed user, uint256 amount, address indexed market);\n    event MarketAuthorized(address indexed market, bool authorized);\n    event FactoryAuthorized(address indexed factory);\n\n    // ============ Modifiers ============\n    \n    modifier onlyOwner() {\n        require(msg.sender == owner, \"YieldVault: not owner\");\n        _;\n    }\n    \n    modifier onlyOwnerOrFactory() {\n        require(msg.sender == owner || msg.sender == authorizedFactory, \"YieldVault: not authorized\");\n        _;\n    }\n    \n    modifier onlyAuthorizedMarket() {\n        require(authorizedMarkets[msg.sender], \"YieldVault: not authorized market\");\n        _;\n    }\n\n    // ============ Constructor ============\n    \n    constructor(address _asset) {\n        asset = IERC20(_asset);\n        yieldAsset = IYieldAsset(_asset);\n        owner = msg.sender;\n    }\n\n    // ============ User Functions ============\n    \n    /**\n     * @notice Deposit yield-bearing assets into the vault.\n     * @param amount The amount of assets to deposit.\n     */\n    function deposit(uint256 amount) external {\n        require(amount > 0, \"YieldVault: zero amount\");\n        \n        // Transfer assets from user\n        require(asset.transferFrom(msg.sender, address(this), amount), \"YieldVault: transfer failed\");\n        \n        // Calculate shares based on current exchange rate\n        uint256 rate = yieldAsset.exchangeRate();\n        uint256 shares = (amount * 1e18) / rate;\n        \n        // Update user deposit\n        UserDeposit storage userDeposit = deposits[msg.sender];\n        userDeposit.shares += shares;\n        userDeposit.principalValue += amount;\n        if (userDeposit.depositTime == 0) {\n            userDeposit.depositTime = block.timestamp;\n        }\n        \n        totalShares += shares;\n        \n        emit Deposited(msg.sender, amount, shares);\n    }\n\n    /**\n     * @notice Withdraw all assets (principal + unlocked yield) from the vault.\n     * @dev User cannot withdraw if they have yield locked in active predictions.\n     */\n    function withdraw() external {\n        UserDeposit storage userDeposit = deposits[msg.sender];\n        require(userDeposit.shares > 0, \"YieldVault: no deposit\");\n        require(userDeposit.lockedYield == 0, \"YieldVault: yield locked in prediction\");\n        \n        uint256 shares = userDeposit.shares;\n        uint256 principal = userDeposit.principalValue;\n        \n        // Calculate current value\n        uint256 rate = yieldAsset.exchangeRate();\n        uint256 currentValue = (shares * rate) / 1e18;\n        uint256 yieldEarned = currentValue > principal ? currentValue - principal : 0;\n        \n        // Reset user deposit\n        delete deposits[msg.sender];\n        totalShares -= shares;\n        \n        // Transfer assets back to user\n        require(asset.transfer(msg.sender, currentValue), \"YieldVault: transfer failed\");\n        \n        emit Withdrawn(msg.sender, principal, yieldEarned);\n    }\n\n    // ============ View Functions ============\n    \n    /**\n     * @notice Get the current value of a user's deposit.\n     * @param user The user address.\n     * @return currentValue The total current value (principal + yield).\n     * @return principal The original principal amount.\n     * @return unlockedYield The yield available for predictions.\n     * @return lockedYield The yield already locked in predictions.\n     */\n    function getDepositInfo(address user) external view returns (\n        uint256 currentValue,\n        uint256 principal,\n        uint256 unlockedYield,\n        uint256 lockedYield\n    ) {\n        UserDeposit storage userDeposit = deposits[user];\n        if (userDeposit.shares == 0) {\n            return (0, 0, 0, 0);\n        }\n        \n        uint256 rate = yieldAsset.exchangeRate();\n        currentValue = (userDeposit.shares * rate) / 1e18;\n        principal = userDeposit.principalValue;\n        lockedYield = userDeposit.lockedYield;\n        \n        uint256 totalYield = currentValue > principal ? currentValue - principal : 0;\n        unlockedYield = totalYield > lockedYield ? totalYield - lockedYield : 0;\n    }\n\n    /**\n     * @notice Get the available yield for a user to use in predictions.\n     * @param user The user address.\n     * @return The available yield amount.\n     */\n    function getAvailableYield(address user) external view returns (uint256) {\n        UserDeposit storage userDeposit = deposits[user];\n        if (userDeposit.shares == 0) {\n            return 0;\n        }\n        \n        uint256 rate = yieldAsset.exchangeRate();\n        uint256 currentValue = (userDeposit.shares * rate) / 1e18;\n        uint256 totalYield = currentValue > userDeposit.principalValue \n            ? currentValue - userDeposit.principalValue \n            : 0;\n        \n        return totalYield > userDeposit.lockedYield \n            ? totalYield - userDeposit.lockedYield \n            : 0;\n    }\n\n    // ============ Market Functions ============\n    \n    /**\n     * @notice Lock a portion of a user's yield for a prediction.\n     * @dev Only callable by authorized market contracts.\n     * @param user The user whose yield to lock.\n     * @param amount The amount of yield to lock.\n     */\n    function lockYield(address user, uint256 amount) external onlyAuthorizedMarket {\n        UserDeposit storage userDeposit = deposits[user];\n        \n        uint256 rate = yieldAsset.exchangeRate();\n        uint256 currentValue = (userDeposit.shares * rate) / 1e18;\n        uint256 totalYield = currentValue > userDeposit.principalValue \n            ? currentValue - userDeposit.principalValue \n            : 0;\n        uint256 availableYield = totalYield > userDeposit.lockedYield \n            ? totalYield - userDeposit.lockedYield \n            : 0;\n        \n        require(amount <= availableYield, \"YieldVault: insufficient yield\");\n        \n        userDeposit.lockedYield += amount;\n        \n        emit YieldLocked(user, amount, msg.sender);\n    }\n\n    /**\n     * @notice Unlock a portion of a user's yield after a prediction resolves.\n     * @dev Only callable by authorized market contracts.\n     * @param user The user whose yield to unlock.\n     * @param amount The amount of yield to unlock.\n     */\n    function unlockYield(address user, uint256 amount) external onlyAuthorizedMarket {\n        UserDeposit storage userDeposit = deposits[user];\n        require(userDeposit.lockedYield >= amount, \"YieldVault: insufficient locked yield\");\n        \n        userDeposit.lockedYield -= amount;\n        \n        emit YieldUnlocked(user, amount, msg.sender);\n    }\n\n    /**\n     * @notice Transfer locked yield from loser to winner after prediction resolves.\n     * @dev Only callable by authorized market contracts.\n     * @param from The loser's address.\n     * @param to The winner's address.\n     * @param amount The amount of yield to transfer.\n     */\n    function transferYield(address from, address to, uint256 amount) external onlyAuthorizedMarket {\n        UserDeposit storage fromDeposit = deposits[from];\n        UserDeposit storage toDeposit = deposits[to];\n        \n        require(fromDeposit.lockedYield >= amount, \"YieldVault: insufficient locked yield\");\n        \n        // Calculate shares to transfer based on current rate\n        uint256 rate = yieldAsset.exchangeRate();\n        uint256 sharesToTransfer = (amount * 1e18) / rate;\n        \n        require(fromDeposit.shares >= sharesToTransfer, \"YieldVault: insufficient shares\");\n        \n        // Transfer shares (the yield portion)\n        fromDeposit.shares -= sharesToTransfer;\n        fromDeposit.lockedYield -= amount;\n        \n        toDeposit.shares += sharesToTransfer;\n        \n        // Note: Winner's principal doesn't change, only their shares increase\n        // This means their \"yield\" calculation will show the transferred amount\n    }\n\n    // ============ Admin Functions ============\n    \n    /**\n     * @notice Authorize or deauthorize a market contract.\n     * @dev Can be called by owner or authorized factory.\n     * @param market The market contract address.\n     * @param authorized Whether to authorize or deauthorize.\n     */\n    function setMarketAuthorization(address market, bool authorized) external onlyOwnerOrFactory {\n        authorizedMarkets[market] = authorized;\n        emit MarketAuthorized(market, authorized);\n    }\n    \n    /**\n     * @notice Set the authorized factory contract.\n     * @param factory The factory contract address.\n     */\n    function setAuthorizedFactory(address factory) external onlyOwner {\n        authorizedFactory = factory;\n        emit FactoryAuthorized(factory);\n    }\n}\n\n// ============ Interface ============\n\ninterface IYieldAsset {\n    function exchangeRate() external view returns (uint256);\n}\n"},"lib/forge-std/src/interfaces/IERC20.sol":{"content":"// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity >=0.6.2;\n\n/// @dev Interface of the ERC20 standard as defined in the EIP.\n/// @dev This includes the optional name, symbol, and decimals metadata.\ninterface IERC20 {\n    /// @dev Emitted when `value` tokens are moved from one account (`from`) to another (`to`).\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /// @dev Emitted when the allowance of a `spender` for an `owner` is set, where `value`\n    /// is the new allowance.\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /// @notice Returns the amount of tokens in existence.\n    function totalSupply() external view returns (uint256);\n\n    /// @notice Returns the amount of tokens owned by `account`.\n    function balanceOf(address account) external view returns (uint256);\n\n    /// @notice Moves `amount` tokens from the caller's account to `to`.\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /// @notice Returns the remaining number of tokens that `spender` is allowed\n    /// to spend on behalf of `owner`\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /// @notice Sets `amount` as the allowance of `spender` over the caller's tokens.\n    /// @dev Be aware of front-running risks: https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /// @notice Moves `amount` tokens from `from` to `to` using the allowance mechanism.\n    /// `amount` is then deducted from the caller's allowance.\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n\n    /// @notice Returns the name of the token.\n    function name() external view returns (string memory);\n\n    /// @notice Returns the symbol of the token.\n    function symbol() external view returns (string memory);\n\n    /// @notice Returns the decimals places of the token.\n    function decimals() external view returns (uint8);\n}\n"}},"settings":{"remappings":["forge-std/=lib/forge-std/src/"],"optimizer":{"enabled":true,"runs":200},"metadata":{"useLiteralContent":false,"bytecodeHash":"ipfs","appendCBOR":true},"outputSelection":{"*":{"":["ast"],"*":["abi","evm.bytecode.object","evm.bytecode.sourceMap","evm.bytecode.linkReferences","evm.deployedBytecode.object","evm.deployedBytecode.sourceMap","evm.deployedBytecode.linkReferences","evm.deployedBytecode.immutableReferences","evm.methodIdentifiers","metadata"]}},"evmVersion":"shanghai","viaIR":false,"libraries":{}}}
