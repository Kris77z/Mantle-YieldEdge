{"language":"Solidity","sources":{"src/MockUSDY.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.23;\n\n/**\n * @title MockUSDY\n * @notice A mock implementation of Ondo's USDY token that simulates yield accrual.\n * @dev For hackathon demo purposes only. Simulates ~5% APY by rebasing.\n *      In production, this would be replaced with actual USDY integration.\n * \n * Yield Mechanism:\n * - Uses a \"rebase\" model where the exchange rate increases over time.\n * - `balanceOf()` returns: shares * exchangeRate\n * - Exchange rate grows by ~0.0137% per day (~5% APY)\n */\ncontract MockUSDY {\n    string public name = \"Mock USDY\";\n    string public symbol = \"mUSDY\";\n    uint8 public decimals = 18;\n    \n    // Precision for exchange rate calculations (18 decimals)\n    uint256 public constant PRECISION = 1e18;\n    \n    // Starting exchange rate: 1 share = 1 USDY\n    uint256 public exchangeRate = PRECISION;\n    \n    // Last time the exchange rate was updated\n    uint256 public lastUpdateTime;\n    \n    // Annual yield rate in basis points (500 = 5%)\n    uint256 public constant ANNUAL_YIELD_BPS = 500;\n    \n    // Mapping from address to shares (internal accounting)\n    mapping(address => uint256) private _shares;\n    \n    // Allowances\n    mapping(address => mapping(address => uint256)) private _allowances;\n    \n    // Total shares issued\n    uint256 private _totalShares;\n\n    // Events\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    constructor() {\n        lastUpdateTime = block.timestamp;\n    }\n\n    /**\n     * @notice Updates the exchange rate based on time elapsed.\n     * @dev Called before any transfer/balance operation to ensure accurate yield calculation.\n     */\n    function accrueYield() public {\n        uint256 timeElapsed = block.timestamp - lastUpdateTime;\n        if (timeElapsed > 0) {\n            // Calculate yield: rate * (1 + APY * timeElapsed / SECONDS_PER_YEAR)\n            // APY = 5% = 0.05 = 500 / 10000\n            uint256 yieldAccrued = (exchangeRate * ANNUAL_YIELD_BPS * timeElapsed) / (10000 * 365 days);\n            exchangeRate += yieldAccrued;\n            lastUpdateTime = block.timestamp;\n        }\n    }\n\n    /**\n     * @notice Mint USDY tokens to an address (for testing/faucet purposes).\n     * @param to The recipient address.\n     * @param amount The amount of USDY to mint (in token units, not shares).\n     */\n    function mint(address to, uint256 amount) external {\n        accrueYield();\n        uint256 sharesToMint = (amount * PRECISION) / exchangeRate;\n        _shares[to] += sharesToMint;\n        _totalShares += sharesToMint;\n        emit Transfer(address(0), to, amount);\n    }\n\n    /**\n     * @notice Returns the USDY balance of an account (including accrued yield).\n     * @param account The address to query.\n     * @return The USDY balance.\n     */\n    function balanceOf(address account) public view returns (uint256) {\n        // Simulate yield accrual without state change for view function\n        uint256 timeElapsed = block.timestamp - lastUpdateTime;\n        uint256 currentRate = exchangeRate;\n        if (timeElapsed > 0) {\n            uint256 yieldAccrued = (exchangeRate * ANNUAL_YIELD_BPS * timeElapsed) / (10000 * 365 days);\n            currentRate += yieldAccrued;\n        }\n        return (_shares[account] * currentRate) / PRECISION;\n    }\n\n    /**\n     * @notice Returns the shares held by an account (internal accounting).\n     * @param account The address to query.\n     * @return The number of shares.\n     */\n    function sharesOf(address account) external view returns (uint256) {\n        return _shares[account];\n    }\n\n    /**\n     * @notice Returns the total supply of USDY (including accrued yield).\n     * @return The total USDY supply.\n     */\n    function totalSupply() public view returns (uint256) {\n        uint256 timeElapsed = block.timestamp - lastUpdateTime;\n        uint256 currentRate = exchangeRate;\n        if (timeElapsed > 0) {\n            uint256 yieldAccrued = (exchangeRate * ANNUAL_YIELD_BPS * timeElapsed) / (10000 * 365 days);\n            currentRate += yieldAccrued;\n        }\n        return (_totalShares * currentRate) / PRECISION;\n    }\n\n    /**\n     * @notice Transfer USDY tokens to another address.\n     * @param to The recipient address.\n     * @param amount The amount of USDY to transfer.\n     * @return True if successful.\n     */\n    function transfer(address to, uint256 amount) public returns (bool) {\n        accrueYield();\n        uint256 sharesToTransfer = (amount * PRECISION) / exchangeRate;\n        require(_shares[msg.sender] >= sharesToTransfer, \"MockUSDY: insufficient balance\");\n        _shares[msg.sender] -= sharesToTransfer;\n        _shares[to] += sharesToTransfer;\n        emit Transfer(msg.sender, to, amount);\n        return true;\n    }\n\n    /**\n     * @notice Transfer USDY tokens from one address to another.\n     * @param from The sender address.\n     * @param to The recipient address.\n     * @param amount The amount of USDY to transfer.\n     * @return True if successful.\n     */\n    function transferFrom(address from, address to, uint256 amount) public returns (bool) {\n        accrueYield();\n        \n        uint256 currentAllowance = _allowances[from][msg.sender];\n        require(currentAllowance >= amount, \"MockUSDY: insufficient allowance\");\n        _allowances[from][msg.sender] = currentAllowance - amount;\n        \n        uint256 sharesToTransfer = (amount * PRECISION) / exchangeRate;\n        require(_shares[from] >= sharesToTransfer, \"MockUSDY: insufficient balance\");\n        _shares[from] -= sharesToTransfer;\n        _shares[to] += sharesToTransfer;\n        emit Transfer(from, to, amount);\n        return true;\n    }\n\n    /**\n     * @notice Approve spender to transfer tokens.\n     * @param spender The address allowed to spend.\n     * @param amount The amount allowed.\n     * @return True if successful.\n     */\n    function approve(address spender, uint256 amount) public returns (bool) {\n        _allowances[msg.sender][spender] = amount;\n        emit Approval(msg.sender, spender, amount);\n        return true;\n    }\n\n    /**\n     * @notice Get the allowance for a spender.\n     * @param owner The token owner.\n     * @param spender The spender address.\n     * @return The remaining allowance.\n     */\n    function allowance(address owner, address spender) public view returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @notice Burn USDY tokens from the caller's account.\n     * @param amount The amount of USDY to burn.\n     */\n    function burn(uint256 amount) external {\n        accrueYield();\n        uint256 sharesToBurn = (amount * PRECISION) / exchangeRate;\n        require(_shares[msg.sender] >= sharesToBurn, \"MockUSDY: insufficient balance\");\n        _shares[msg.sender] -= sharesToBurn;\n        _totalShares -= sharesToBurn;\n        emit Transfer(msg.sender, address(0), amount);\n    }\n\n    // ============ Fast Forward (Testing Only) ============\n\n    /**\n     * @notice Fast forwards time simulation for testing purposes.\n     * @dev Only for testing! Simulates `days_` days of yield accrual.\n     * @param days_ Number of days to fast forward.\n     */\n    function fastForwardDays(uint256 days_) external {\n        uint256 yieldAccrued = (exchangeRate * ANNUAL_YIELD_BPS * days_ * 1 days) / (10000 * 365 days);\n        exchangeRate += yieldAccrued;\n        lastUpdateTime = block.timestamp;\n    }\n}\n"}},"settings":{"remappings":["forge-std/=lib/forge-std/src/"],"optimizer":{"enabled":true,"runs":200},"metadata":{"useLiteralContent":false,"bytecodeHash":"ipfs","appendCBOR":true},"outputSelection":{"*":{"":["ast"],"*":["abi","evm.bytecode.object","evm.bytecode.sourceMap","evm.bytecode.linkReferences","evm.deployedBytecode.object","evm.deployedBytecode.sourceMap","evm.deployedBytecode.linkReferences","evm.deployedBytecode.immutableReferences","evm.methodIdentifiers","metadata"]}},"evmVersion":"shanghai","viaIR":false,"libraries":{}}}
